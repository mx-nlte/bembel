// This file is part of Bembel, the higher order C++ boundary element library.
//
// Copyright (C) 2023 see <http://www.bembel.eu>
//
// It was written as part of a cooperation of J. Doelz, H. Harbrecht, S. Kurz,
// M. Multerer, S. Schoeps, and F. Wolf at Technische Universitaet Darmstadt,
// Universitaet Basel, and Universita della Svizzera italiana, Lugano. This
// source code is subject to the GNU General Public License version 3 and
// provided WITHOUT ANY WARRANTY, see <http://www.bembel.eu> for further
// information.

#include <Bembel/AnsatzSpace>
#include <Bembel/Geometry>
#include <Bembel/H2Matrix>
#include <Bembel/IO>
#include <Bembel/LinearForm>
#include <Bembel/Maxwell>
#include <Eigen/Dense>
#include <iostream>

#include "examples/Data.hpp"
#include "examples/Error.hpp"
#include "examples/Grids.hpp"

int main() {
  using namespace Bembel;
  using namespace Eigen;

  int polynomial_degree = 1;
  int refinement_level = 3;
  std::complex<double> wavenumber(2., 0.);

  // Load geometry from file "sphere.dat", which must be placed in the same
  // directory as the executable
  Geometry geometry("hemisphere.dat");

  // Define analytical solution using lambda function, in this case a dipole
  // centered on 0, see Data.hpp
  const std::function<VectorXcd(Vector3d)> fun = [wavenumber](Vector3d pt) {
    return Data::Dipole(pt, wavenumber, Vector3d(0.2, 0.2, 0.2),
                        Vector3d(0., 0.1, 0.1));
  };

  std::cout << "\n" << std::string(60, '=') << "\n";

  // Build ansatz space
  AnsatzSpace<MaxwellSingleLayerOperator> ansatz_space(
      geometry, refinement_level, polynomial_degree);

  // Set up load vector
  DiscreteLinearForm<RotatedTangentialTrace<std::complex<double>>,
                     MaxwellSingleLayerOperator>
      disc_lf(ansatz_space);
  disc_lf.get_linear_form().set_function(fun);
  disc_lf.compute();

  // Set up and compute discrete operator
  DiscreteOperator<MatrixXcd, MaxwellSingleLayerOperator> disc_op(
      ansatz_space);
  disc_op.get_linear_operator().set_wavenumber(wavenumber);
  disc_op.compute();

  // solve system
  PartialPivLU<MatrixXcd> lu;
  lu.compute(disc_op.get_discrete_operator());
  auto rho = lu.solve(disc_lf.get_discrete_linear_form());

  // Evaluator for the surface current
  FunctionEvaluator<MaxwellSingleLayerOperator> evaluator(ansatz_space);
  evaluator.set_function(rho);

  // plot the real part of the surface current
  std::function<Eigen::Vector3d(int, const Eigen::Vector2d&)> current_real =
      [&](int patch_number, const Eigen::Vector2d& reference_domain_point) {
        return (evaluator.evaluateOnPatch(patch_number, reference_domain_point))
            .array()
            .real();
      };

  // With the help of these functions, the data sets are generated by the
  const int refinement_level_plot = 4;

  // The VTKwriter sets up initial geomety information.
  VTKSurfaceExport writer(geometry, refinement_level_plot);

  // VTKWriter
  writer.addDataSet("Surface Current [Re]", current_real);

  // Finally, we print to file.
  writer.writeToFile("screen.vtp");

  std::cout << std::string(60, '=') << std::endl;

  return 0;
}
